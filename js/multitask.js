// Generated by CoffeeScript 1.6.2
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  window.onload = function() {
    var i, pong, saved, tetris, x, y, _i, _j;

    root.ach9 = 0;
    root.gameConfig = {
      lvl: [[1, 0], [2, 20], [3, 45], [4, 75], [5, 110], [6, 150], [7, 195], [8, 245], [9, 300], [10, 360]],
      score: [null, null],
      achieve: {
        descript: ['Receive "A" rank', 'Receive "S" rank', 'Receive "SS" rank', 'Receive "SSS" rank', 'Clear 4 lines in single drop [ Tetris ]', 'Clear same color of line [ Tetris ]', 'Left 3 lifes even game end [ Pong ]', 'Play game at least 1 time', 'Play tetris game in 1 second', 'Die both game in same time', 'Reach to maximum level of both game ( Level 10 )', 'Play game at least 5 minutes', 'Every subscore (except \'other\') in both game not different more than 5%', 'Receive score without move [ Pong ]', 'Visit credit page :D', 'Receive "SSS" rank in "every subscore" in "both game" ( Oh GOD )'],
        score: (function() {
          var _i, _results;

          _results = [];
          for (_i = 0; _i < 16; _i++) {
            _results.push(0);
          }
          return _results;
        })()
      }
    };
    tetris = (function() {
      var canvas, colorMap, drawStage, gameEnd, genNextShape, init, layer, log, placeShape, prevShape, score, setSpeed, shapeDown, shapeMap, stage, updateScore, _gameState, _timeRender, _timeScore;

      _gameState = null;

      _timeRender = null;

      _timeScore = null;

      stage = (function() {
        var _i, _results;

        _results = [];
        for (_i = 0; _i < 20; _i++) {
          _results.push((function() {
            var _j, _results1;

            _results1 = [];
            for (_j = 0; _j < 10; _j++) {
              _results1.push('E');
            }
            return _results1;
          })());
        }
        return _results;
      })();

      canvas = null;

      layer = [];

      score = {
        game: 'tetris',
        score: 0,
        level: 0,
        line: 0,
        time: 0
      };

      log = {
        nextShape: 'E',
        curShape: 'E',
        movingPiece: [],
        state: 'begin',
        speed: 1000,
        randPiece: []
      };

      colorMap = {
        I: '#00BFFF',
        J: '#104E8B',
        L: '#FF7F24',
        O: '#FFB90F',
        S: '#9ACD32',
        T: '#473C8B',
        Z: '#CD0000'
      };

      shapeMap = {
        I: [[1, 1, 1, 1]],
        J: [[1, 0, 0], [1, 1, 1]],
        L: [[0, 0, 1], [1, 1, 1]],
        O: [[1, 1], [1, 1]],
        S: [[0, 1, 1], [1, 1, 0]],
        T: [[0, 1, 0], [1, 1, 1]],
        Z: [[1, 1, 0], [0, 1, 1]]
      };

      setSpeed = function(level) {
        log.speed = (11 - level) * 100;
        return score.level = level;
      };

      tetris.prototype.moveShape = function(type) {
        var c, pass, tmp, _i, _len, _ref;

        if (log.state !== "play") {
          return;
        }
        tmp = (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push([c[0], c[1]]);
          }
          return _results;
        })();
        pass = true;
        for (_i = 0, _len = tmp.length; _i < _len; _i++) {
          c = tmp[_i];
          if (type === 'L') {
            --c[0];
          } else if (type === 'R') {
            ++c[0];
          } else {
            ++c[1];
          }
          if (!((0 <= (_ref = c[0]) && _ref < 10)) || c[1] >= 20 || (c[1] >= 0 && stage[c[1]][c[0]] !== 'E')) {
            pass = false;
            break;
          }
        }
        if (pass) {
          log.movingPiece = tmp;
          return prevShape();
        }
      };

      tetris.prototype.rotation = function() {
        var c, cx, cy, ex, ey, pass, pcx, sx, tmp, x, y, _i, _len;

        if (log.state !== "play") {
          return;
        }
        cx = ((Math.max.apply(Math, (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c[0]);
          }
          return _results;
        })())) + (Math.min.apply(Math, (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c[0]);
          }
          return _results;
        })()))) / 2;
        pcx = (cx - Math.floor(cx)) !== 0;
        cx = Math.floor(cx);
        cy = Math.ceil(((Math.max.apply(Math, (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c[1]);
          }
          return _results;
        })())) + (Math.min.apply(Math, (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c[1]);
          }
          return _results;
        })()))) / 2);
        tmp = (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push([-(c[1] - cy) + cx, c[0] - cx + cy]);
          }
          return _results;
        })();
        sx = Math.min.apply(Math, (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = tmp.length; _i < _len; _i++) {
            c = tmp[_i];
            _results.push(c[0]);
          }
          return _results;
        })());
        sx = Math.min(0, sx);
        ex = Math.max.apply(Math, (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = tmp.length; _i < _len; _i++) {
            c = tmp[_i];
            _results.push(c[0]);
          }
          return _results;
        })());
        ex = Math.max(9, ex);
        ey = Math.max.apply(Math, (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = tmp.length; _i < _len; _i++) {
            c = tmp[_i];
            _results.push(c[1]);
          }
          return _results;
        })());
        ey = Math.max(19, ey);
        tmp = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = tmp.length; _i < _len; _i++) {
            c = tmp[_i];
            x = (ex >= 10 ? c[0] - (ex - 9) : sx < 0 ? c[0] - sx : c[0]);
            y = c[1] - pcx - (ey > 19 ? ey - 19 : 0);
            _results.push([x, y]);
          }
          return _results;
        })();
        pass = true;
        for (_i = 0, _len = tmp.length; _i < _len; _i++) {
          c = tmp[_i];
          if (c[1] >= 0 && stage[c[1]][c[0]] !== 'E') {
            pass = false;
            break;
          }
        }
        if (pass) {
          log.movingPiece = tmp;
          return prevShape();
        }
      };

      drawStage = function() {
        var elm, i, j, _i, _j;

        layer[3].removeChildren();
        layer[3].remove();
        for (i = _i = 0; _i < 20; i = ++_i) {
          for (j = _j = 0; _j < 10; j = ++_j) {
            if (stage[i][j] === 'E') {
              continue;
            }
            elm = new Kinetic.Rect({
              x: 170 + j * 25,
              y: 20 + i * 25,
              width: 24,
              height: 24,
              fill: colorMap[stage[i][j]]
            });
            layer[3].add(elm);
          }
        }
        canvas.add(layer[3]);
      };

      updateScore = function(phase) {
        var c, elm, i, newlvl, textShow, tmp, v, _i, _len, _ref;

        if (phase == null) {
          phase = 0;
        }
        layer[4].removeChildren();
        layer[4].remove();
        c = 0;
        tmp = score.time;
        score.time = (score.time / 10 || 0) + " s";
        newlvl = 0;
        _ref = root.gameConfig.lvl;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          if (tmp / 10 > i[1]) {
            newlvl = i[0];
          }
        }
        setSpeed(newlvl);
        for (i in score) {
          v = score[i];
          if (i === 'game') {
            continue;
          }
          elm = new Kinetic.Text({
            x: 30,
            y: 440 + c * 17,
            text: i.substr(0, 1).toUpperCase() + i.substr(1) + ' : ' + v,
            fontSize: 14,
            fontFamily: "arial",
            fill: '#FFF'
          });
          layer[4].add(elm);
          c++;
        }
        if (phase !== 0) {
          elm = new Kinetic.Rect({
            x: 170,
            y: 20,
            width: 250,
            height: 500,
            opacity: 0.5,
            fill: '#000'
          });
          layer[4].add(elm);
          textShow = [0, "Click Play to Start Game", "Game Over", "Pause", "Bad Luck"];
          elm = new Kinetic.Text({
            x: 170 + 250 / 2 - 100,
            y: 20 + 500 / 2,
            text: textShow[phase],
            fontSize: 70,
            fontFamily: "bebas",
            fill: '#FF8C00',
            width: 200,
            align: 'center'
          });
          if (phase === 1) {
            elm.setY(170 + 500 / 2 - 320);
          } else if (phase === 2) {
            elm.setY(170 + 500 / 2 - 220);
          } else if (phase === 3) {
            elm.setY(170 + 500 / 2 - 180);
          } else if (phase === 4) {
            elm.setY(170 + 500 / 2 - 220);
          }
          layer[4].add(elm);
        }
        if (phase === 0) {
          score.time = parseInt(tmp) + 1;
        } else {
          score.time = tmp;
        }
        canvas.add(layer[4]);
      };

      placeShape = function() {
        var c, colorline, countline, i, j, pass, rev, _i, _j, _k, _l, _len, _m, _n, _o, _ref;

        _ref = log.movingPiece;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c[1] >= 0) {
            stage[c[1]][c[0]] = log.curShape;
          }
        }
        drawStage();
        rev = [];
        countline = 0;
        colorline = 0;
        for (i = _j = 19; _j >= 0; i = --_j) {
          pass = true;
          for (j = _k = 0; _k < 10; j = ++_k) {
            if (stage[i][j] === 'E') {
              pass = false;
            }
          }
          if (!pass) {
            rev.push(i);
          } else {
            colorline = 1;
            for (j = _l = 1; _l < 10; j = ++_l) {
              if (stage[i][j] !== stage[i][0]) {
                colorline = 0;
              }
            }
            if (colorline) {
              root.gameAchievement(2, 5);
            }
            countline++;
          }
        }
        if (countline === 4) {
          root.gameAchievement(2, 4);
        }
        score.score = parseInt(score.score) + (20 - rev.length) * (20 - rev.length) * 100 * (11 - (log.speed / 100));
        score.line = parseInt(score.line) + (20 - rev.length);
        if (rev.length !== 0) {
          for (i = _m = 19; _m > 0; i = --_m) {
            if (rev.length === 0) {
              for (j = _n = 0; _n < 10; j = ++_n) {
                stage[i][j] = 'E';
              }
            } else {
              for (j = _o = 0; _o < 10; j = ++_o) {
                stage[i][j] = stage[rev[0]][j];
              }
              rev.shift();
            }
          }
          drawStage();
          genNextShape();
          return;
        } else {
          genNextShape();
        }
      };

      tetris.prototype.shapeDownDrop = function() {
        var btm, c, i, pass;

        if (log.state !== 'play') {
          return;
        }
        btm = log.movingPiece;
        while (true) {
          pass = true;
          for (i in btm) {
            c = btm[i];
            if (++btm[i][1] < 0) {
              continue;
            }
            if (c[1] >= 20 || stage[c[1]][c[0]] !== 'E') {
              pass = false;
            }
          }
          if (!pass) {
            for (i in btm) {
              c = btm[i];
              --btm[i][1];
            }
            break;
          }
        }
        log.movingPiece = btm;
        return shapeDown();
      };

      shapeDown = function() {
        var c, crd, mvp;

        mvp = log.movingPiece;
        mvp = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = mvp.length; _i < _len; _i++) {
            crd = mvp[_i];
            _results.push([crd[0], crd[1] + 1]);
          }
          return _results;
        })();
        if ((Math.max.apply(Math, (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = mvp.length; _i < _len; _i++) {
            c = mvp[_i];
            _results.push(c[1]);
          }
          return _results;
        })())) >= 20 || !(((function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = mvp.length; _i < _len; _i++) {
            c = mvp[_i];
            _results.push(c[1] >= 0 ? stage[c[1]][c[0]] : 'E');
          }
          return _results;
        })()).every(function(x) {
          return x === 'E';
        }))) {
          if ((Math.min.apply(Math, (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = mvp.length; _i < _len; _i++) {
              c = mvp[_i];
              _results.push(c[1]);
            }
            return _results;
          })())) < 0) {
            gameEnd();
            return;
          }
          score.score = parseInt(score.score) + (11 - (log.speed / 100)) + 10;
          placeShape();
          return;
        }
        log.movingPiece = mvp;
        prevShape();
        clearTimeout(_timeRender);
        _timeRender = setTimeout(shapeDown, log.speed);
      };

      genNextShape = function() {
        var a, b, elm, h, i, j, newS, sq, sx, sy, t, tmp, v, vj, _i, _ref, _ref1;

        tmp = log.nextShape;
        if (log.randPiece.length === 0) {
          sq = ["I", "J", "L", "O", "S", "T", "Z"];
          for (_i = 1; _i <= 10; _i++) {
            a = Math.floor(Math.random() * sq.length);
            b = Math.floor(Math.random() * sq.length);
            t = sq[a];
            sq[a] = sq[b];
            sq[b] = t;
          }
          sq = sq.slice(0, 6 + Math.floor(Math.random() * 2));
          log.randPiece = sq;
        }
        newS = log.nextShape = log.randPiece.shift();
        if (tmp === 'E') {
          genNextShape();
          return;
        }
        sx = 20 + 130 / 2 - shapeMap[newS][0].length * 28 / 2;
        sy = 20 + 90 / 2 - shapeMap[newS].length * 30 / 2;
        layer[1].removeChildren();
        layer[1].remove();
        _ref = shapeMap[newS];
        for (i in _ref) {
          v = _ref[i];
          for (j in v) {
            vj = v[j];
            if (vj === 0) {
              continue;
            }
            elm = new Kinetic.Rect({
              x: sx + j * 28,
              y: sy + i * 28 + 30,
              width: 26,
              height: 26,
              fill: colorMap[newS]
            });
            layer[1].add(elm);
          }
        }
        elm = new Kinetic.Rect({
          x: 20,
          y: 20 + 30,
          width: 130,
          height: 90,
          opacity: 0.03,
          fill: colorMap[newS]
        });
        layer[1].add(elm);
        elm = new Kinetic.Rect({
          x: 18,
          y: 18 + 30,
          width: 134,
          height: 94,
          opacity: 0.2,
          stroke: colorMap[newS],
          strokeWidth: 0
        });
        layer[1].add(elm);
        canvas.add(layer[1]);
        h = shapeMap[tmp].length;
        log.movingPiece = [];
        _ref1 = shapeMap[tmp];
        for (i in _ref1) {
          v = _ref1[i];
          for (j in v) {
            vj = v[j];
            if (vj === 1) {
              log.movingPiece.push([5 - Math.floor(v.length / 2) + parseInt(j), i - h]);
            }
          }
        }
        log.curShape = tmp;
        shapeDown();
      };

      function tetris(state) {
        _gameState = state;
        init();
      }

      tetris.prototype.gameBegin = function() {
        log.state = 'play';
        score.level = 1;
        updateScore();
        genNextShape();
        _timeScore = setInterval(updateScore, 100);
      };

      tetris.prototype.gamePause = function() {
        if (log.state === 'end') {
          return;
        }
        log.state = 'pause';
        updateScore(3);
        clearTimeout(_timeRender);
        clearInterval(_timeScore);
      };

      tetris.prototype.gameResume = function() {
        if (log.state === 'end') {
          return;
        }
        log.state = 'play';
        _timeScore = setInterval(updateScore, 100);
        shapeDown();
      };

      gameEnd = function() {
        log.state = 'end';
        updateScore(2);
        clearTimeout(_timeRender);
        clearInterval(_timeScore);
        root.gameEnd(_gameState);
      };

      tetris.prototype.gameEndBefore = function() {
        if (log.state !== 'end') {
          log.state = 'end';
          updateScore(4);
          clearTimeout(_timeRender);
          return clearInterval(_timeScore);
        }
      };

      tetris.prototype.gameReset = function() {
        clearInterval(_timeRender);
        clearInterval(_timeScore);
        stage = (function() {
          var _i, _results;

          _results = [];
          for (_i = 0; _i < 20; _i++) {
            _results.push((function() {
              var _j, _results1;

              _results1 = [];
              for (_j = 0; _j < 10; _j++) {
                _results1.push('E');
              }
              return _results1;
            })());
          }
          return _results;
        })();
        score = {
          game: 'tetris',
          score: 0,
          level: 0,
          line: 0,
          time: 0
        };
        log = {
          nextShape: 'E',
          curShape: 'E',
          movingPiece: [],
          state: 'begin',
          speed: 1000,
          randPiece: []
        };
        return drawStage();
      };

      init = function() {
        var elm, i, img, _i;

        canvas = new Kinetic.Stage({
          container: 'tetris',
          width: 438,
          height: 540
        });
        layer = [];
        for (i = _i = 0; _i < 5; i = ++_i) {
          layer[i] = new Kinetic.Layer();
        }
        elm = new Kinetic.Rect({
          x: 150 + 20,
          y: 20,
          width: 250,
          height: 500,
          fill: '#DDD'
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 150 + 18,
          y: 18,
          width: 254,
          height: 504,
          stroke: '#EEE',
          strokeWidth: 0
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 20,
          y: 20 + 30,
          width: 130,
          height: 90,
          fill: '#DDD'
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 18,
          y: 18 + 30,
          width: 134,
          height: 94,
          stroke: '#EEE',
          strokeWidth: 0
        });
        layer[0].add(elm);
        elm = new Kinetic.Shape({
          drawFunc: function(canvas) {
            var c;

            c = canvas.getContext();
            c.beginPath();
            c.moveTo(18, 47);
            c.lineTo(18, 18);
            c.lineTo(100, 18);
            c.lineTo(130, 47);
            c.closePath();
            return canvas.fillStroke(this);
          },
          fill: '#300'
        });
        layer[0].add(elm);
        elm = new Kinetic.Text({
          x: 30,
          y: 24,
          text: 'Next',
          fontSize: 18,
          fontFamily: "bebas",
          fill: '#FFF'
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 18,
          y: 404,
          width: 134,
          height: 120,
          fill: '#698B22'
        });
        layer[0].add(elm);
        elm = new Kinetic.Text({
          x: 27,
          y: 414,
          text: 'Score',
          fontSize: 18,
          fontFamily: "bebas",
          fill: '#FFF'
        });
        layer[0].add(elm);
        img = new Image();
        img.onload = function() {
          elm = new Kinetic.Image({
            x: 18,
            y: 160,
            width: 134,
            height: 120,
            image: img
          });
          layer[0].add(elm);
          canvas.add(layer[0]);
          updateScore(1);
        };
        img.src = "t1.png";
      };

      prevShape = function() {
        var btm, c, coord, elm, i, mvp, pass, _i, _j, _len, _len1;

        mvp = log.movingPiece;
        btm = (function() {
          var _i, _len, _ref, _results;

          _ref = log.movingPiece;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push([c[0], c[1]]);
          }
          return _results;
        })();
        while (true) {
          pass = true;
          for (i in btm) {
            c = btm[i];
            if (++btm[i][1] < 0) {
              continue;
            }
            if (c[1] >= 20 || stage[c[1]][c[0]] !== 'E') {
              pass = false;
            }
          }
          if (!pass) {
            for (i in btm) {
              c = btm[i];
              --btm[i][1];
            }
            break;
          }
        }
        layer[2].removeChildren();
        layer[2].remove();
        for (_i = 0, _len = mvp.length; _i < _len; _i++) {
          coord = mvp[_i];
          if (coord[1] < 0) {
            continue;
          }
          elm = new Kinetic.Rect({
            x: 170 + coord[0] * 25,
            y: 20 + coord[1] * 25,
            width: 24,
            height: 24,
            fill: colorMap[log.curShape]
          });
          layer[2].add(elm);
        }
        for (_j = 0, _len1 = btm.length; _j < _len1; _j++) {
          coord = btm[_j];
          if (coord[1] < 0) {
            continue;
          }
          elm = new Kinetic.Rect({
            x: 170 + coord[0] * 25,
            y: 20 + coord[1] * 25,
            width: 24,
            height: 24,
            opacity: 0.2,
            fill: colorMap[log.curShape]
          });
          layer[2].add(elm);
        }
        return canvas.add(layer[2]);
      };

      tetris.prototype.getScore = function() {
        return score;
      };

      tetris.prototype.test = {
        test2: function() {
          var i, j, _i, _j;

          log.state = 'end';
          clearTimeout(_timeRender);
          for (i = _i = 19; _i >= 4; i = --_i) {
            for (j = _j = 0; _j < 10; j = ++_j) {
              stage[i][j] = "IIIIE"[Math.floor(Math.random() * 5)];
            }
          }
          drawStage();
          return $(document).keydown(function(e) {
            var pass, rev, _k, _l, _m;

            rev = [];
            for (i = _k = 19; _k >= 0; i = --_k) {
              pass = true;
              for (j = _l = 0; _l < 10; j = ++_l) {
                if (stage[i][j] === 'E') {
                  pass = false;
                }
              }
              if (!pass) {
                rev.push(i);
              } else {
                for (j = _m = 0; _m < 10; j = ++_m) {
                  stage[i][j] = 'O';
                }
              }
            }
            drawStage();
            return $(document).keydown(function(e) {
              var _n, _o, _p;

              for (i = _n = 19; _n > 0; i = --_n) {
                if (rev.length === 0) {
                  for (j = _o = 0; _o < 10; j = ++_o) {
                    stage[i][j] = 'E';
                  }
                } else {
                  for (j = _p = 0; _p < 10; j = ++_p) {
                    stage[i][j] = stage[rev[0]][j];
                  }
                  rev.shift();
                }
              }
              return drawStage();
            });
          });
        },
        stop: function() {
          log.state = 'end';
          return clearTimeout(_timeRender);
        }
      };

      return tetris;

    })();
    /*
    	---------------------------------------------------------
    	Game Pong
    	---------------------------------------------------------
    */

    pong = (function() {
      var ballRender, canvas, gameDie, gameEnd, init, initStage, interact, layer, log, map, prevRender, score, setSpeed, updateScore, _gameState, _interval;

      _gameState = null;

      canvas = null;

      layer = null;

      _interval = {
        score: null
      };

      map = null;

      score = {
        game: 'pong',
        score: 0,
        level: 0,
        lifes: 3,
        time: 0,
        move: 0
      };

      interact = {
        board: null,
        enimies: null,
        ballDir: [],
        speed: 1000
      };

      log = {
        state: 'begin'
      };

      setSpeed = function(level) {
        interact.speed = (11 - level) * 100;
        return score.level = level;
      };

      pong.prototype.gameBegin = function() {
        log.state = 'play';
        score.level = 1;
        _interval.score = setInterval(updateScore, 100);
        updateScore();
        return initStage();
      };

      pong.prototype.gamePause = function() {
        if (log.state === 'die') {
          return;
        }
        log.state = 'pause';
        clearInterval(_interval.score);
        return updateScore(3);
      };

      pong.prototype.gameResume = function() {
        if (log.state === 'die') {
          return;
        }
        if (log.state === 'pausedie') {
          initStage();
        }
        log.state = 'play';
        clearInterval(_interval.score);
        return _interval.score = setInterval(updateScore, 100);
      };

      gameDie = function() {
        score.move = 0;
        if (--score.lifes <= 0) {
          gameEnd();
          return;
        }
        updateScore();
        clearInterval(_interval.score);
        return setTimeout(function() {
          if (log.state === 'pause') {
            log.state = 'pausedie';
            return;
          }
          _interval.score = setInterval(updateScore, 100);
          return initStage();
        }, 1000);
      };

      gameEnd = function() {
        log.state = 'die';
        clearInterval(_interval.score);
        updateScore(2);
        return root.gameEnd(_gameState);
      };

      pong.prototype.gameEndBefore = function() {
        if (log.state !== 'die') {
          log.state = 'die';
          clearInterval(_interval.score);
          return updateScore(4);
        }
      };

      pong.prototype.gameReset = function() {
        clearInterval(_interval.score);
        score = {
          game: 'pong',
          score: 0,
          level: 0,
          lifes: 3,
          time: 0,
          move: 0
        };
        log.state = 'begin';
        interact = {
          board: null,
          enimies: null,
          ballDir: [],
          speed: 1000
        };
        return map = null;
      };

      function pong(state) {
        _gameState = state;
        init();
      }

      init = function() {
        var elm, i, img, _i;

        canvas = new Kinetic.Stage({
          container: 'pong',
          width: 442,
          height: 540
        });
        layer = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          layer[i] = new Kinetic.Layer();
        }
        elm = new Kinetic.Rect({
          x: 20,
          y: 20,
          width: 250,
          height: 500,
          fill: '#DDD'
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 18,
          y: 18,
          width: 254,
          height: 504,
          stroke: '#EEE',
          strokeWidth: 0
        });
        layer[0].add(elm);
        elm = new Kinetic.Rect({
          x: 270 + 18,
          y: 404,
          width: 134,
          height: 120,
          fill: '#698B22'
        });
        layer[0].add(elm);
        elm = new Kinetic.Text({
          x: 270 + 27,
          y: 414,
          text: 'Score',
          fontSize: 18,
          fontFamily: "bebas",
          fill: '#FFF'
        });
        layer[0].add(elm);
        img = new Image();
        img.onload = function() {
          elm = new Kinetic.Image({
            x: 270 + 18,
            y: 160,
            width: 134,
            height: 120,
            image: img
          });
          layer[0].add(elm);
          canvas.add(layer[0]);
          updateScore(1);
        };
        img.src = "t2.png";
      };

      initStage = function() {
        interact.board = 3;
        interact.enimies = 3;
        interact.ballDir = [[1, -1], [-1, -1]][Math.floor(Math.random() * 2)];
        prevRender();
        return ballRender();
      };

      pong.prototype.move = function(type) {
        var tmp;

        if (log.state !== 'play') {
          return;
        }
        tmp = interact.board;
        if (type === 'L') {
          if (tmp !== 0) {
            tmp--;
          }
        } else {
          if (tmp + 3 !== 9) {
            tmp++;
          }
        }
        interact.board = tmp;
        prevRender();
        score.move++;
      };

      ballRender = function() {
        var aim, bs, count, elm, intt, stop, x, y;

        layer[2].removeChildren();
        layer[2].remove();
        intt = interact;
        count = 1;
        bs = 6;
        x = 20 + [4, 5][Math.floor(Math.random() * 2)] * 25 + 12.5;
        y = 20 + 18 * 25 - bs;
        elm = new Kinetic.Circle({
          x: x,
          y: y,
          radius: bs,
          fill: '#CD0000'
        });
        layer[2].add(elm);
        stop = false;
        if (intt.speed !== 0) {
          aim = new Kinetic.Animation(function(frame) {
            var check, pass, rand, speed, sx, tmp, _ref, _ref1;

            if (stop) {
              aim.stop();
              gameDie();
            }
            intt = interact;
            speed = intt.speed;
            if (log.state !== 'play') {
              if (log.state === 'die') {
                aim.stop();
              } else {
                return;
              }
            }
            check = (intt.board <= (_ref = Math.floor((x - 20) / 25)) && _ref <= intt.board + 3);
            if (x >= 20 + 10 * 25 - bs) {
              intt.ballDir[0] *= -1;
              x = 20 + 10 * 25 - bs;
            }
            if (x <= 20 + bs) {
              intt.ballDir[0] *= -1;
              x = 20 + bs;
            }
            if (y <= 20 + 2 * 25 + bs) {
              intt.ballDir[1] *= -1;
              y = 20 + 2 * 25 + bs;
            }
            if (((20 + 18 * 25 - bs <= y && y <= 20 + 18 * 25 + 12.5)) && check) {
              if (count !== 1) {
                score.score += (11 - (speed / 100)) * ((intt.board < (_ref1 = Math.floor((x - 20) / 25)) && _ref1 < intt.board + 3) ? 10 : 20) + 100;
                score.score += Math.max(0, 10 - score.move);
                if (score.move === 0) {
                  root.gameConfig.achieve.score[13] = 1;
                }
              }
              intt.ballDir[1] *= -1;
              score.move = 0;
              y = 20 + 18 * 25 - bs;
            }
            x += 100 * (frame.timeDiff / speed) * intt.ballDir[0];
            y += 100 * (frame.timeDiff / speed) * intt.ballDir[1];
            if (y >= 20 + 20 * 25 - bs) {
              y = 20 + 20 * 25 - bs;
              stop = true;
            }
            elm.setX(x);
            elm.setY(y);
            if (frame.time >= speed / 4 * count) {
              sx = Math.floor((x - 20) / 25);
              if (sx < intt.enimies) {
                interact.enimies--;
              } else if (sx > intt.enimies + 4 - 1) {
                interact.enimies++;
              } else {
                rand = [1 * intt.ballDir[0], 0, 0, 0, 0][Math.floor(Math.random() * 6)];
                tmp = intt.enimies + rand;
                pass = false;
                if ((tmp <= sx && sx < tmp + 4)) {
                  pass = true;
                }
                if (!((0 <= tmp && tmp <= 6))) {
                  pass = false;
                }
                if (pass) {
                  intt.enimies = tmp;
                }
              }
              prevRender();
              return count++;
            }
          }, layer[2]);
          aim.start();
        }
        return canvas.add(layer[2]);
      };

      prevRender = function() {
        var c, elm, _i, _j, _ref, _ref1, _ref2, _ref3;

        layer[1].removeChildren();
        layer[1].remove();
        for (c = _i = _ref = interact.board, _ref1 = interact.board + 4; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; c = _ref <= _ref1 ? ++_i : --_i) {
          elm = new Kinetic.Rect({
            x: 20 + c * 25,
            y: 20 + 18 * 25,
            width: 24,
            height: 12,
            fill: '#ff8b00'
          });
          layer[1].add(elm);
        }
        for (c = _j = _ref2 = interact.enimies, _ref3 = interact.enimies + 4; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; c = _ref2 <= _ref3 ? ++_j : --_j) {
          elm = new Kinetic.Rect({
            x: 20 + c * 25,
            y: 20 + 1 * 25 + 12.5,
            width: 24,
            height: 12,
            fill: '#320000'
          });
          layer[1].add(elm);
        }
        return canvas.add(layer[1]);
      };

      updateScore = function(phase) {
        var c, elm, i, newlvl, textShow, tmp, v, _i, _len, _ref;

        if (phase == null) {
          phase = 0;
        }
        layer[3].removeChildren();
        layer[3].remove();
        c = 0;
        tmp = score.time;
        score.time = (score.time / 10 || 0) + " s";
        newlvl = 0;
        _ref = root.gameConfig.lvl;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          if (tmp / 10 > i[1]) {
            newlvl = i[0];
          }
        }
        setSpeed(newlvl);
        for (i in score) {
          v = score[i];
          if (i === 'move' || i === 'game') {
            continue;
          }
          elm = new Kinetic.Text({
            x: 300,
            y: 440 + c * 17,
            text: i.substr(0, 1).toUpperCase() + i.substr(1) + ' : ' + v,
            fontSize: 14,
            fontFamily: "arial",
            fill: '#FFF'
          });
          layer[3].add(elm);
          c++;
        }
        if (phase !== 0) {
          elm = new Kinetic.Rect({
            x: 20,
            y: 20,
            width: 250,
            height: 500,
            opacity: 0.5,
            fill: '#000'
          });
          layer[3].add(elm);
          textShow = [0, "Click Play to Start Game", "Game Over", "Pause", "Bad Luck"];
          elm = new Kinetic.Text({
            x: 20 + 250 / 2 - 100,
            y: 20 + 500 / 2,
            text: textShow[phase],
            fontSize: 70,
            fontFamily: "bebas",
            fill: '#FF8C00',
            width: 200,
            align: 'center'
          });
          if (phase === 1) {
            elm.setY(170 + 500 / 2 - 320);
          } else if (phase === 2) {
            elm.setY(170 + 500 / 2 - 220);
          } else if (phase === 3) {
            elm.setY(170 + 500 / 2 - 180);
          } else if (phase === 4) {
            elm.setY(170 + 500 / 2 - 220);
          }
          layer[3].add(elm);
        }
        if (phase === 0) {
          score.time = parseInt(tmp) + 1;
        } else {
          score.time = tmp;
        }
        canvas.add(layer[3]);
      };

      pong.prototype.getScore = function() {
        return score;
      };

      return pong;

    })();
    $(document).keydown(function(e) {
      var key;

      key = [32, 37, 38, 39, 40];
      if (key.indexOf(e.which) !== -1) {
        e.preventDefault();
      }
      switch (e.which) {
        case 32:
          return root.game.shapeDownDrop();
        case 37:
          root.game.moveShape('L');
          return root.game2.move('L');
        case 38:
          return root.game.rotation();
        case 39:
          root.game.moveShape('R');
          return root.game2.move('R');
        case 40:
          return root.game.moveShape('D');
      }
    });
    root.game = new tetris(1);
    root.game2 = new pong(2);
    root.gameStart = function() {
      var ach9;

      ach9 = 0;
      root.game.gameReset();
      root.game2.gameReset();
      root.game.gameBegin();
      return root.game2.gameBegin();
    };
    root.gameEnd = function(which) {
      ach9++;
      if (which === 1) {
        return setTimeout(function() {
          root.game2.gameEndBefore();
          root.gameShowRank();
          return root.gameAchievement();
        }, 1000);
      } else {
        return setTimeout(function() {
          root.game.gameEndBefore();
          root.gameShowRank();
          return root.gameAchievement();
        }, 1000);
      }
    };
    root.gameShowRank = function() {
      var a, ach12, ach15, grading, i, ii, j, jj, kk, lastgrade, max, n, quote, s, v, _ref;

      if (root.gameConfig.score[0] !== null) {
        return;
      }
      root.gameConfig.score[0] = root.game.getScore();
      root.gameConfig.score[1] = root.game2.getScore();
      $("#handle").text('Play');
      a = [root.gameConfig.score[0], root.gameConfig.score[1]];
      grading = function(v) {
        var g, i, s, _i, _ref;

        s = [200, 160, 120, 90, 60, 40, 20, 10, 0];
        g = ['SSS', 'SS', 'S', 'A', 'B', 'C', 'D', 'E', 'F'];
        if (g.indexOf(v) !== -1) {
          return s[g.indexOf(v)] / 100;
        }
        v = v * 100 + 1;
        for (i = _i = 0, _ref = s.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (v > s[i]) {
            return g[i];
          }
        }
      };
      lastgrade = 0;
      ach12 = true;
      ach15 = true;
      _ref = a[0];
      for (i in _ref) {
        v = _ref[i];
        if (i === 'lifes') {
          i = 'line';
        }
        n = ['game', 'score', 'level', 'line', 'time'].indexOf(i);
        if (n === -1) {
          continue;
        }
        j = i;
        if (i === 'line' && a[0]['game'] === 'pong') {
          i = 'lifes';
        }
        if (j === 'line' && a[1]['game'] === 'pong') {
          j = 'lifes';
        }
        ii = a[0][i];
        jj = a[1][j];
        if (i !== 'game') {
          ii = parseInt(ii);
          jj = parseInt(jj);
        }
        s = ["", "", ""];
        kk = 0;
        switch (i) {
          case 'score':
            max = a[0]['game'] === 'tetris' ? 35000 : 15000;
            s[0] = grading(ii / max);
            max = a[1]['game'] === 'tetris' ? 35000 : 15000;
            s[1] = grading(jj / max);
            if (Math.abs(ii - jj) / Math.max(ii, jj) > 0.05) {
              ach12 = false;
            }
            kk = ii + jj;
            s[2] = grading(kk / 50000);
            lastgrade += (grading(s[0]) + grading(s[1])) / 2 * 2;
            break;
          case 'level':
            s[0] = grading(ii * ii / 50);
            s[1] = grading(jj * jj / 50);
            if (Math.abs(ii - jj) / Math.max(ii, jj) > 0.05) {
              ach12 = false;
            }
            if (Math.min(ii, jj) === 10) {
              root.gameConfig.achieve.score[10] = 1;
            }
            kk = Math.max(ii, jj);
            s[2] = grading(kk * kk / 50);
            lastgrade += (grading(s[0]) + grading(s[1])) / 2 * 2;
            break;
          case 'line':
          case 'lifes':
            if (i === 'line') {
              s[0] = grading(ii / 50);
            }
            if (j === 'line') {
              s[1] = grading(jj / 50);
            }
            if (i === 'lifes') {
              s[0] = grading((ii * (11 / 3) + 9) / 10);
            }
            if (j === 'lifes') {
              s[1] = grading((jj * (11 / 3) + 9) / 10);
            }
            lastgrade += Math.min(grading(s[0]), grading(s[1]));
            break;
          case 'time':
            s[0] = grading(ii / 3600);
            s[1] = grading(jj / 3600);
            s[2] = grading(Math.max(ii, jj) / 3600);
            kk = Math.max(ii, jj) / 10 + ' S';
            if (Math.min(ii, jj) > 3000) {
              root.gameConfig.achieve.score[11] = 1;
            }
            if (Math.abs(ii - jj) / Math.max(ii, jj) > 0.05) {
              ach12 = false;
            }
            if (i === 'time' && ii < 10) {
              root.gameAchievement(2, 8);
            }
            ii = ii / 10 + ' S';
            jj = jj / 10 + ' S';
            lastgrade += (grading(s[0]) + grading(s[1])) / 2 * 2;
        }
        if (j === 'lifes' && jj === 3) {
          root.gameAchievement(2, 6);
        }
        if (s[0] !== 'SSS' || s[1] !== 'SSS') {
          ach15 = false;
        }
        if (i !== 'game') {
          if (i === 'line' || i === 'lifes') {
            if (i === 'line') {
              i += 's';
            }
            if (j === 'line') {
              j += 's';
            }
            ii = "" + ii + "&nbsp;&nbsp;" + i + "&nbsp;&nbsp;<span style='color:#300;'>[ " + s[0] + " ]</span>";
            jj = "" + jj + "&nbsp;&nbsp;" + j + "&nbsp;&nbsp;<span style='color:#300;'>[ " + s[1] + " ]</span>";
            if (grading(s[0]) < grading(s[1])) {
              kk = ii;
            } else {
              kk = jj;
            }
          } else {
            ii = "" + ii + "&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:#300;'>[ " + s[0] + " ]</span>";
            jj = "" + jj + "&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:#300;'>[ " + s[1] + " ]</span>";
            kk = "" + kk + "&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:#300;'>[ " + s[2] + " ]</span>";
          }
        }
        $("#score-ct .summary table tr:eq(" + n + ") td:eq(1)").html("" + ii);
        $("#score-ct .summary table tr:eq(" + n + ") td:eq(2)").html("" + jj);
        if (i !== 'game') {
          $("#score-ct .summary table tr:eq(" + n + ") td:eq(3)").html("" + kk);
        }
      }
      if (ach12 === true) {
        root.gameAchievement(2, 12);
      }
      if (ach15 === true) {
        root.gameAchievement(2, 15);
      }
      lastgrade = grading(lastgrade / 7);
      quote = [["You're not human !!!!", "OMG, WTF, How can you do that !!?", "%)@^#!$%|<*#)+_#!~", "You are GODDD !!!!"], ["Impossible !!!", "How many brains you have ?", "You completely talented !!!"], ["Perfect !!", "OMGGG !!", "Very impressive"], ["Excellent !", "Very Very Good", "WOW !", "Genius"], ["Cool", "Great", "Good"], ["Ordinary", "Normal", "Regular"], ["Not bad", "Ok"], ["Try again later", "Not good enough", "Try one more time"], ["What are you doing ?", "Don't hold spacbar", "......"]][['SSS', 'SS', 'S', 'A', 'B', 'C', 'D', 'E', 'F'].indexOf(lastgrade)];
      quote = quote[Math.floor(Math.random() * quote.length)];
      $("#score-ct .summary table tr:last-child td:last-child").html(lastgrade + "&nbsp;&nbsp;&nbsp;&nbsp;<span style='color:#300; font-size:18px;'>[&nbsp;&nbsp;" + quote + "&nbsp;&nbsp;]</span>");
      $("#score-ct .grade").text(lastgrade);
      switch (lastgrade) {
        case 'A':
          root.gameAchievement(2, 0);
          break;
        case 'S':
          root.gameAchievement(2, 1);
          break;
        case 'SS':
          root.gameAchievement(2, 2);
          break;
        case 'SSS':
          root.gameAchievement(2, 3);
      }
      $("#score-ct").fadeIn();
      $("#score-ct .score").fadeIn();
      $('html, body').animate({
        scrollTop: $("#score-ct").offset().top
      }, 1500);
      return setTimeout(function() {
        return root.gameConfig.score = [null, null];
      }, 1000);
    };
    $("#handle").click(function() {
      if ($(this).text() === 'Play') {
        $('html, body').animate({
          scrollTop: $("#game-ct > div:eq(0)").offset().top + 5
        }, 1000);
        $(this).text('Pause');
        return root.gameStart();
      } else if ($(this).text() === 'Pause') {
        $(this).text('Continue');
        root.game.gamePause();
        return root.game2.gamePause();
      } else if ($(this).text() === 'Continue') {
        $('html, body').animate({
          scrollTop: $("#game-ct > div:eq(0)").offset().top + 5
        }, 1000);
        $(this).text('Pause');
        root.game.gameResume();
        return root.game2.gameResume();
      }
    });
    for (i = _i = 0; _i < 16; i = ++_i) {
      x = i % 4 * 157.5;
      y = Math.floor(i / 4) * 157.5;
      $("#score-ct .achieve .roll div:eq(" + i + ")").css({
        "background-position": "-" + x + "px -" + y + "px"
      }).mousemove(function(e) {
        var txt;

        txt = root.gameConfig.achieve.descript[$(this).index()];
        return $("#score-ct .achieve .roll p").css({
          left: e.pageX + 10,
          top: e.pageY + 12,
          display: 'block'
        }).text(txt);
      }).mouseout(function() {
        return $("#score-ct .achieve .roll p").hide();
      });
    }
    root.gameAchievement = function(type, param) {
      var ach, c, saved, _j;

      if (type == null) {
        type = 0;
      }
      if (param == null) {
        param = null;
      }
      root.gameConfig.achieve.score[7] = 1;
      if (root.ach9 === 2) {
        root.gameConfig.achieve.score[9] = 1;
      }
      if (type === 0) {
        setTimeout(function() {
          return root.gameAchievement(1);
        }, 1500);
      } else if (type === 1) {
        ach = root.gameConfig.achieve.score;
        c = 0;
        saved = "";
        for (i = _j = 0; _j < 16; i = ++_j) {
          saved += ach[i] + "";
          if (ach[i] === 1) {
            $("#score-ct .achieve .roll div:eq(" + i + ")").addClass("pass");
          }
        }
        return localStorage["game.multitask"] = saved;
      } else if (type === 2) {
        root.gameConfig.achieve.score[param] = 1;
        if (param === 14) {
          root.gameAchievement(1);
          return window.open("../..", "_blank");
        }
      }
    };
    saved = localStorage.getItem("game.multitask") || "0000000000000000";
    for (i = _j = 0; _j < 16; i = ++_j) {
      root.gameConfig.achieve.score[i] = parseInt(saved[i]);
    }
    if (root.gameConfig.achieve.score[7] !== 1) {
      $("#score-ct").hide();
    } else {
      root.gameAchievement(1);
    }
    document.getElementById("share-twt").setAttribute("src", "https://platform.twitter.com/widgets/tweet_button.html?count=none&url=" + encodeURIComponent(document.URL) + "&text=" + encodeURIComponent("How great MULTITASK are you ? Tetris & Pong Battle !!!") + "&dnt=true");
    $("#preloading").fadeOut('fast');
  };

}).call(this);
